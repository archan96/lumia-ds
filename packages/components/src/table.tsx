import type { HTMLAttributes, TableHTMLAttributes } from 'react';
import {
  Children,
  createContext,
  forwardRef,
  isValidElement,
  useContext,
  useState,
} from 'react';
import { cn } from './utils';

type TableDensity = 'comfortable' | 'compact';
type TableAlignment = 'left' | 'center' | 'right';
export type TableSortDirection = 'asc' | 'desc' | 'none';
export type TableSortState = {
  columnId: string;
  direction: TableSortDirection;
};
export type TableColumn = {
  id: string;
  label: string;
  sortable?: boolean;
  align?: TableAlignment;
};

type TableContextValue = {
  density: TableDensity;
  zebra: boolean;
  stickyHeader: boolean;
};

const TableContext = createContext<TableContextValue>({
  density: 'comfortable',
  zebra: false,
  stickyHeader: false,
});

const TableSectionContext = createContext<'header' | 'body'>('body');

const densityClasses: Record<TableDensity, string> = {
  comfortable: 'h-12 px-4 py-3',
  compact: 'h-10 px-3 py-2',
};

const alignmentClasses: Record<TableAlignment, string> = {
  left: 'text-left',
  center: 'text-center',
  right: 'text-right',
};

const useTableContext = () => useContext(TableContext);
const useTableSection = () => useContext(TableSectionContext);
const defaultSortCycle: TableSortDirection[] = ['asc', 'desc', 'none'];

const toAriaSort = (direction: TableSortDirection) => {
  switch (direction) {
    case 'asc':
      return 'ascending';
    case 'desc':
      return 'descending';
    default:
      return 'none';
  }
};

const getNextDirection = (
  current: TableSortDirection,
  cycle: TableSortDirection[],
): TableSortDirection => {
  if (cycle.length === 0) return current;

  const currentIndex = cycle.indexOf(current);
  if (currentIndex === -1) return cycle[0] ?? 'none';

  const nextIndex = (currentIndex + 1) % cycle.length;
  return cycle[nextIndex] ?? 'none';
};

const SortIcon = ({ direction }: { direction: TableSortDirection }) => (
  <span className="flex h-4 w-4 items-center justify-center text-muted-foreground">
    <svg
      aria-hidden="true"
      viewBox="0 0 16 16"
      className="h-3.5 w-3.5"
      fill="none"
      stroke="currentColor"
      strokeWidth="1.25"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path
        d="M5.25 9.5 8 12.25 10.75 9.5"
        className={cn(
          'transition-opacity',
          direction === 'desc' ? 'opacity-100' : 'opacity-50',
        )}
      />
      <path
        d="M5.25 6.5 8 3.75 10.75 6.5"
        className={cn(
          'transition-opacity',
          direction === 'asc' ? 'opacity-100' : 'opacity-50',
        )}
      />
    </svg>
  </span>
);

export type TableProps = TableHTMLAttributes<HTMLTableElement> & {
  density?: TableDensity;
  zebra?: boolean;
  stickyHeader?: boolean;
  columns?: TableColumn[];
  sort?: TableSortState | null;
  defaultSort?: TableSortState | null;
  sortCycle?: TableSortDirection[];
  onSortChange?: (sort: TableSortState) => void;
};

export const Table = forwardRef<HTMLTableElement, TableProps>(function Table(
  {
    children,
    className,
    density = 'comfortable',
    zebra = false,
    stickyHeader = false,
    columns,
    sort: controlledSort,
    defaultSort = null,
    sortCycle,
    onSortChange,
    ...props
  },
  ref,
) {
  const isControlled = controlledSort !== undefined;
  const [internalSort, setInternalSort] = useState<TableSortState | null>(
    defaultSort,
  );

  const resolvedSort = isControlled ? (controlledSort ?? null) : internalSort;
  const resolvedCycle =
    sortCycle && sortCycle.length > 0 ? sortCycle : defaultSortCycle;

  const hasColumns = Boolean(columns && columns.length > 0);
  const headerDisplayName = TableHeader.displayName;
  const hasCustomHeader = Children.toArray(children).some(
    (child) =>
      isValidElement(child) &&
      (child.type === TableHeader ||
        (!!headerDisplayName &&
          (child.type as { displayName?: string })?.displayName ===
            headerDisplayName)),
  );

  const handleSortToggle = (columnId: string) => {
    const currentDirection =
      resolvedSort?.columnId === columnId ? resolvedSort.direction : 'none';
    const nextDirection = getNextDirection(currentDirection, resolvedCycle);
    const nextSort: TableSortState = { columnId, direction: nextDirection };

    if (!isControlled) {
      setInternalSort(nextSort);
    }
    onSortChange?.(nextSort);
  };

  const autogeneratedHeader =
    hasColumns && !hasCustomHeader ? (
      <TableHeader>
        <TableRow>
          {columns?.map((column) => {
            const direction =
              resolvedSort?.columnId === column.id
                ? resolvedSort.direction
                : 'none';
            const ariaSort = column.sortable
              ? toAriaSort(direction)
              : undefined;
            const justifyContent =
              column.align === 'right'
                ? 'justify-end text-right'
                : column.align === 'center'
                  ? 'justify-center text-center'
                  : 'justify-start text-left';

            return (
              <TableCell
                key={column.id}
                as="th"
                align={column.align}
                aria-sort={ariaSort}
              >
                {column.sortable ? (
                  <button
                    type="button"
                    aria-pressed={direction !== 'none'}
                    onClick={() => handleSortToggle(column.id)}
                    className={cn(
                      'group inline-flex w-full items-center gap-2 font-semibold tracking-wide text-muted-foreground',
                      justifyContent,
                    )}
                  >
                    <span className="whitespace-nowrap">{column.label}</span>
                    <SortIcon direction={direction} />
                  </button>
                ) : (
                  column.label
                )}
              </TableCell>
            );
          })}
        </TableRow>
      </TableHeader>
    ) : null;

  return (
    <TableContext.Provider value={{ density, zebra, stickyHeader }}>
      <table
        ref={ref}
        className={cn(
          'w-full border border-border/80 bg-background text-sm text-foreground border-separate border-spacing-0 rounded-lg shadow-sm overflow-hidden',
          className,
        )}
        {...props}
      >
        {autogeneratedHeader}
        {children}
      </table>
    </TableContext.Provider>
  );
});

export type TableHeaderProps = HTMLAttributes<HTMLTableSectionElement>;
export const TableHeader = forwardRef<
  HTMLTableSectionElement,
  TableHeaderProps
>(function TableHeader({ children, className, ...props }, ref) {
  return (
    <TableSectionContext.Provider value="header">
      <thead
        ref={ref}
        className={cn('bg-muted/60 text-muted-foreground', className)}
        {...props}
      >
        {children}
      </thead>
    </TableSectionContext.Provider>
  );
});

export type TableBodyProps = HTMLAttributes<HTMLTableSectionElement>;
export const TableBody = forwardRef<HTMLTableSectionElement, TableBodyProps>(
  function TableBody({ children, className, ...props }, ref) {
    return (
      <TableSectionContext.Provider value="body">
        <tbody
          ref={ref}
          className={cn(
            'bg-background [&_tr:last-child_td]:border-b-0 [&_tr:last-child_th]:border-b-0 [&_tr:last-child_td:first-child]:rounded-bl-lg [&_tr:last-child_td:last-child]:rounded-br-lg',
            className,
          )}
          {...props}
        >
          {children}
        </tbody>
      </TableSectionContext.Provider>
    );
  },
);

export type TableRowProps = HTMLAttributes<HTMLTableRowElement>;
export const TableRow = forwardRef<HTMLTableRowElement, TableRowProps>(
  function TableRow({ className, ...props }, ref) {
    const { zebra } = useTableContext();
    const section = useTableSection();

    return (
      <tr
        ref={ref}
        className={cn(
          'transition-colors',
          section === 'body' && 'hover:bg-muted/40',
          section === 'body' && zebra && 'odd:bg-muted/30',
          className,
        )}
        {...props}
      />
    );
  },
);

export type TableCellProps = HTMLAttributes<HTMLTableCellElement> & {
  as?: 'td' | 'th';
  align?: TableAlignment;
};

export const TableCell = forwardRef<HTMLTableCellElement, TableCellProps>(
  function TableCell(
    { as = 'td', align = 'left', className, children, ...props },
    ref,
  ) {
    const { density, stickyHeader } = useTableContext();
    const section = useTableSection();
    const Component = as;
    const isHeaderCell = section === 'header' || as === 'th';

    return (
      <Component
        ref={ref as never}
        className={cn(
          'align-middle border-b border-border/70',
          densityClasses[density],
          alignmentClasses[align],
          isHeaderCell
            ? 'text-xs font-semibold uppercase tracking-wide text-muted-foreground'
            : 'text-sm text-foreground',
          stickyHeader &&
            isHeaderCell &&
            'sticky top-0 z-10 bg-muted/70 backdrop-blur-sm',
          section === 'header' && 'first:rounded-tl-lg last:rounded-tr-lg',
          className,
        )}
        {...props}
      >
        {children}
      </Component>
    );
  },
);
