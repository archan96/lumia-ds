#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const [, , sourceDirArg, iconsPackageArg] = process.argv;

const usage = () => {
  console.error(
    'Usage: lumia-icon-import <svg-source-folder> [icons-package-root]',
  );
  console.error('Example: lumia-icon-import packages/icons/raw packages/icons');
  process.exit(1);
};

if (!sourceDirArg || sourceDirArg === '--help') {
  usage();
}

const sourceDir = path.resolve(process.cwd(), sourceDirArg);
const iconsPackageRoot = path.resolve(
  process.cwd(),
  iconsPackageArg || path.join('packages', 'icons'),
);
const generatedRoot = path.join(iconsPackageRoot, 'src', 'generated');
const componentsDir = path.join(generatedRoot, 'icons');

const generatedIndexPath = path.join(generatedRoot, 'index.ts');
const generatedRegistryPath = path.join(generatedRoot, 'registry.ts');

if (!fs.existsSync(sourceDir)) {
  console.error(`Source folder not found: ${sourceDir}`);
  process.exit(1);
}

if (!fs.statSync(sourceDir).isDirectory()) {
  console.error(`Source path is not a directory: ${sourceDir}`);
  process.exit(1);
}

const svgFiles = fs
  .readdirSync(sourceDir)
  .filter((file) => file.toLowerCase().endsWith('.svg'));

if (svgFiles.length === 0) {
  console.error(`No .svg files found in ${sourceDir}`);
  process.exit(1);
}

fs.mkdirSync(componentsDir, { recursive: true });

function toPascalCase(value) {
  return (
    value
      .split(/[^a-zA-Z0-9]+/)
      .filter(Boolean)
      .map((segment) => segment[0].toUpperCase() + segment.slice(1))
      .join('') || 'Icon'
  );
}

function toKebabCase(value) {
  return value
    .trim()
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/[_\s]+/g, '-')
    .replace(/-+/g, '-')
    .toLowerCase();
}

function toJsxAttributeName(name) {
  if (name === 'class') return 'className';
  return name.replace(/[-:](.)/g, (_, char) => char.toUpperCase());
}

function parseSvg(source) {
  const cleaned = source.trim();
  const match = cleaned.match(/<svg([^>]*)>([\s\S]*?)<\/svg>/i);

  if (!match) {
    throw new Error('Invalid SVG: missing <svg> root');
  }

  const [, rawAttributes, inner] = match;

  const attributes = {};
  const attrRegex = /([\w:-]+)\s*=\s*["']([^"']+)["']/g;
  let attrMatch;

  while ((attrMatch = attrRegex.exec(rawAttributes)) !== null) {
    const [, rawName, rawValue] = attrMatch;
    attributes[toJsxAttributeName(rawName)] = rawValue;
  }

  if (!attributes.viewBox) {
    attributes.viewBox = '0 0 24 24';
  }

  if (!attributes.xmlns) {
    attributes.xmlns = 'http://www.w3.org/2000/svg';
  }

  return {
    attributes,
    innerMarkup: inner.trim(),
  };
}

function formatPropsObject(attrs) {
  const entries = Object.entries(attrs).map(([key, value]) => {
    const renderedValue =
      typeof value === 'string' ? `'${value.replace(/'/g, "\\'")}'` : value;
    return `  ${key}: ${renderedValue}`;
  });

  return `{\n${entries.join(',\n')},\n}`;
}

function renderComponent(componentName, svgMarkup, attributes) {
  const propsObject = formatPropsObject(attributes);
  const svgMarkupLiteral = svgMarkup.replace(/`/g, '\\`');

  return `// Auto-generated by lumia-icon-import. Do not edit by hand.
import type { SVGProps } from 'react';

const svgMarkup = \`${svgMarkupLiteral}\`;

const svgProps = ${propsObject} as const;

export function ${componentName}(props: SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...svgProps}
      {...props}
      dangerouslySetInnerHTML={{ __html: svgMarkup }}
    />
  );
}

export default ${componentName};
`;
}

function renderIndex(iconEntries) {
  if (iconEntries.length === 0) {
    return '// Auto-generated by lumia-icon-import. No icons found.\nexport {};\n';
  }

  const exports = iconEntries
    .map(
      ({ componentName }) =>
        `export { ${componentName} } from './icons/${componentName}';`,
    )
    .join('\n');

  return `// Auto-generated by lumia-icon-import. Do not edit by hand.
${exports}
`;
}

function renderRegistry(iconEntries) {
  const imports =
    iconEntries.length === 0
      ? ''
      : iconEntries
          .map(
            ({ componentName }) =>
              `import { ${componentName} } from './icons/${componentName}';`,
          )
          .join('\n');

  const registrations =
    iconEntries.length === 0
      ? '  // No generated icons were discovered.'
      : iconEntries
          .map(
            ({ iconId, componentName }) =>
              `  registerIcon('${iconId}', ${componentName});`,
          )
          .join('\n');

  return `// Auto-generated by lumia-icon-import. Do not edit by hand.
import type { RegisterIconFn } from '../types';
${imports}

export function registerGeneratedIcons(registerIcon: RegisterIconFn) {
${registrations}
}
`;
}

function cleanComponentDirectory() {
  fs.readdirSync(componentsDir).forEach((file) => {
    if (file.endsWith('.tsx')) {
      fs.unlinkSync(path.join(componentsDir, file));
    }
  });
}

function main() {
  const generatedIcons = [];
  cleanComponentDirectory();

  svgFiles.forEach((file) => {
    const baseName = path.parse(file).name;
    const iconId = toKebabCase(baseName);
    const componentName = `${toPascalCase(baseName)}Icon`;
    const svgPath = path.join(sourceDir, file);
    const svgContent = fs.readFileSync(svgPath, 'utf8');

    const { attributes, innerMarkup } = parseSvg(svgContent);
    const componentSource = renderComponent(
      componentName,
      innerMarkup,
      attributes,
    );

    const targetPath = path.join(componentsDir, `${componentName}.tsx`);
    fs.writeFileSync(targetPath, componentSource, 'utf8');

    generatedIcons.push({ iconId, componentName });
    console.log(`Generated ${componentName} from ${file}`);
  });

  fs.writeFileSync(generatedIndexPath, renderIndex(generatedIcons), 'utf8');
  fs.writeFileSync(
    generatedRegistryPath,
    renderRegistry(generatedIcons),
    'utf8',
  );

  console.log(
    `Wrote ${generatedIcons.length} icon(s) to ${path.relative(process.cwd(), generatedRoot)}`,
  );
}

main();
